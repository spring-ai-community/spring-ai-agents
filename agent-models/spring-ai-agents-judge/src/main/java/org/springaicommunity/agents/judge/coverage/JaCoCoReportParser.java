/*
 * Copyright 2024 Spring AI Community
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springaicommunity.agents.judge.coverage;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Parser for JaCoCo XML coverage reports.
 *
 * <p>
 * Parses jacoco.xml reports generated by the JaCoCo Maven plugin to extract coverage
 * metrics including line, branch, and method coverage percentages.
 * </p>
 *
 * <p>
 * Example usage:
 * </p>
 * <pre>{@code
 * Path reportPath = workspace.resolve("target/site/jacoco/jacoco.xml");
 * CoverageMetrics metrics = JaCoCoReportParser.parse(reportPath);
 * System.out.println("Line coverage: " + metrics.lineCoverage() + "%");
 * }</pre>
 *
 * @author Mark Pollack
 * @since 0.1.0
 */
public class JaCoCoReportParser {

	private static final Logger logger = LoggerFactory.getLogger(JaCoCoReportParser.class);

	/**
	 * Parse JaCoCo XML report from default location.
	 * @param workspace the Maven project root directory
	 * @return coverage metrics
	 */
	public static CoverageMetrics parse(Path workspace) {
		Path reportPath = workspace.resolve("target/site/jacoco/jacoco.xml");
		return parseReport(reportPath);
	}

	/**
	 * Parse JaCoCo XML report from specific path.
	 * @param reportPath path to jacoco.xml file
	 * @return coverage metrics
	 */
	public static CoverageMetrics parseReport(Path reportPath) {
		if (!Files.exists(reportPath)) {
			logger.warn("JaCoCo report not found at: {}", reportPath);
			return new CoverageMetrics(0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0, "JaCoCo report not found at: " + reportPath);
		}

		try {
			logger.debug("Parsing JaCoCo report: {}", reportPath);

			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			// Disable DTD validation and external entity loading for security and to
			// avoid
			// FileNotFoundException when DTD is not locally available
			factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
			factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
			factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
			DocumentBuilder builder = factory.newDocumentBuilder();
			Document doc = builder.parse(reportPath.toFile());

			// Get root <report> element
			Element report = doc.getDocumentElement();

			// Find all <counter> elements
			NodeList counters = report.getElementsByTagName("counter");

			int linesCovered = 0;
			int linesTotal = 0;
			int branchesCovered = 0;
			int branchesTotal = 0;
			int methodsCovered = 0;
			int methodsTotal = 0;

			// Extract counters
			for (int i = 0; i < counters.getLength(); i++) {
				Element counter = (Element) counters.item(i);
				String type = counter.getAttribute("type");
				int covered = Integer.parseInt(counter.getAttribute("covered"));
				int missed = Integer.parseInt(counter.getAttribute("missed"));
				int total = covered + missed;

				switch (type) {
					case "LINE":
						linesCovered = covered;
						linesTotal = total;
						break;
					case "BRANCH":
						branchesCovered = covered;
						branchesTotal = total;
						break;
					case "METHOD":
						methodsCovered = covered;
						methodsTotal = total;
						break;
				}
			}

			// Calculate percentages
			double lineCoverage = linesTotal > 0 ? (linesCovered * 100.0 / linesTotal) : 0.0;
			double branchCoverage = branchesTotal > 0 ? (branchesCovered * 100.0 / branchesTotal) : 0.0;
			double methodCoverage = methodsTotal > 0 ? (methodsCovered * 100.0 / methodsTotal) : 0.0;

			String summary = String.format("Line: %.1f%% (%d/%d), Branch: %.1f%% (%d/%d), Method: %.1f%% (%d/%d)",
					lineCoverage, linesCovered, linesTotal, branchCoverage, branchesCovered, branchesTotal,
					methodCoverage, methodsCovered, methodsTotal);

			logger.info("Parsed JaCoCo report: {}", summary);

			return new CoverageMetrics(lineCoverage, branchCoverage, methodCoverage, linesCovered, linesTotal,
					branchesCovered, branchesTotal, methodsCovered, methodsTotal, summary);

		}
		catch (Exception e) {
			logger.error("Failed to parse JaCoCo report: {}", reportPath, e);
			return new CoverageMetrics(0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0,
					"Failed to parse JaCoCo report: " + e.getMessage());
		}
	}

	/**
	 * Coverage metrics extracted from JaCoCo report.
	 *
	 * @param lineCoverage line coverage percentage (0-100)
	 * @param branchCoverage branch coverage percentage (0-100)
	 * @param methodCoverage method coverage percentage (0-100)
	 * @param linesCovered number of covered lines
	 * @param linesTotal total number of lines
	 * @param branchesCovered number of covered branches
	 * @param branchesTotal total number of branches
	 * @param methodsCovered number of covered methods
	 * @param methodsTotal total number of methods
	 * @param summary human-readable summary
	 */
	public record CoverageMetrics(double lineCoverage, double branchCoverage, double methodCoverage, int linesCovered,
			int linesTotal, int branchesCovered, int branchesTotal, int methodsCovered, int methodsTotal,
			String summary) {
	}

}
