= AgentClient API
:page-title: AgentClient API Reference
:toc: left
:tabsize: 2
:sectnums:

The `AgentClient` offers a fluent API for communicating with autonomous agents. It provides a familiar interface for Spring developers, following the same patterns as Spring AI's `ChatClient`.

The fluent API allows you to build up goal requests that are passed to autonomous agents. Unlike traditional chat models that process conversational prompts, autonomous agents execute goals that can involve reading files, running commands, and making code changes.

== Creating an AgentClient

The `AgentClient` is created using an `AgentModel` instance. Here is a simple example showing the complete flow:

[source,java]
----
import org.springaicommunity.agents.client.AgentClient;
import org.springaicommunity.agents.client.AgentClientResponse;
import org.springaicommunity.agents.claude.ClaudeAgentModel;
import org.springaicommunity.agents.claude.ClaudeAgentOptions;
import org.springaicommunity.agents.claude.sdk.ClaudeAgentClient;

public class HelloAgentWorld {
    public static void main(String[] args) {
        // 1. Create the Claude Code client
        ClaudeAgentClient claudeClient = ClaudeAgentClient.create();

        // 2. Configure agent options
        ClaudeAgentOptions options = ClaudeAgentOptions.builder()
            .model("claude-sonnet-4-0")
            .yolo(true)
            .build();

        // 3. Create the agent model
        ClaudeAgentModel agentModel = new ClaudeAgentModel(claudeClient, options);
        
        // 4. Create AgentClient
        AgentClient agentClient = AgentClient.create(agentModel);
        
        // 5. Execute a goal
        AgentClientResponse response = agentClient.run(
            "Create a simple Hello World Java class"
        );
        
        // 6. Use the result
        System.out.println("Goal completed: " + response.isSuccessful());
        System.out.println("Result: " + response.getResult());
    }
}
----

In this example:

1. We create a `ClaudeAgentClient` that manages communication with the Claude CLI
2. We configure options like the model to use and whether to allow changes (`yolo`)
3. We wrap the client in a `ClaudeAgentModel` for Spring AI integration
4. We create an `AgentClient` using the agent model
5. We run a simple goal using the `.run()` method
6. We access the results and check if the goal was successful

== Basic Usage

=== Simple Goal Execution

The simplest way to run a goal:

[source,java]
----
// Assuming you have an AgentClient created as shown above
AgentClientResponse response = agentClient.run("Create a Hello World Java class");

System.out.println("Result: " + response.getResult());
System.out.println("Success: " + response.isSuccessful());
----

=== Fluent API Configuration

For more control over execution:

[source,java]
----
AgentClientResponse response = agentClient
    .goal("Refactor the UserService class to use dependency injection")
    .workingDirectory("/path/to/project")
    .yolo(true)
    .run();
----

== Configuration Options

=== Working Directory

Set the directory where the agent operates:

[source,java]
----
// Using string path
agentClient.goal("Generate unit tests")
    .workingDirectory("/home/user/my-project")
    .run();

// Using Path object
Path projectPath = Paths.get(System.getProperty("user.dir"));
agentClient.goal("Generate unit tests")
    .workingDirectory(projectPath)
    .run();
----

=== YOLO Mode

Enable or disable the agent's ability to make changes without confirmation:

[source,java]
----
// Enable YOLO mode for development
agentClient.goal("Fix all compilation errors")
    .yolo(true)
    .run();

// Disable for safe analysis
agentClient.goal("Analyze code quality issues")
    .yolo(false)
    .run();
----

=== Agent-Specific Options

Configure agent-specific behavior:

[source,java]
----
ClaudeAgentOptions options = ClaudeAgentOptions.builder()
    .model("claude-sonnet-4-0")
    .maxTokens(8192)
    .timeout(Duration.ofMinutes(10))
    .build();

agentClient.goal("Generate comprehensive documentation")
    .options(options)
    .run();
----

== Response Handling

=== AgentClientResponse

The response object provides access to results and metadata:

[source,java]
----
AgentClientResponse response = agentClient.run("Generate a README file");

// Check if goal completed successfully
if (response.isSuccessful()) {
    String result = response.getResult();
    System.out.println("Agent completed: " + result);
} else {
    System.err.println("Goal failed: " + response.getResult());
}

// Access metadata
AgentResponseMetadata metadata = response.getMetadata();
Duration duration = metadata.getDuration();
String model = metadata.getModel();
----

=== Error Handling

Handle various error conditions:

[source,java]
----
try {
    AgentClientResponse response = agentClient.run("Complex refactoring goal");
    
    if (!response.isSuccessful()) {
        // Goal completed but failed
        System.err.println("Agent reported failure: " + response.getResult());
    }
    
} catch (AgentExecutionException e) {
    // Agent process failed to start or crashed
    System.err.println("Execution error: " + e.getMessage());
    
} catch (AgentTimeoutException e) {
    // Goal exceeded timeout
    System.err.println("Goal timed out after: " + e.getTimeout());
}
----

== Spring Boot Integration

=== Dependency Injection

Configure AgentClient as a Spring bean:

[source,java]
----
@Configuration
public class AgentConfiguration {

    @Bean
    public ClaudeAgentClient claudeAgentClient() {
        return ClaudeAgentClient.create();
    }

    @Bean
    public ClaudeAgentModel claudeAgentModel(ClaudeAgentClient client) {
        ClaudeAgentOptions options = ClaudeAgentOptions.builder()
            .model("claude-sonnet-4-0")
            .yolo(false) // Safe for production
            .build();
        return new ClaudeAgentModel(client, options);
    }

    @Bean
    public AgentClient agentClient(ClaudeAgentModel agentModel) {
        return AgentClient.create(agentModel);
    }
}
----

=== Controller Usage

Use in REST controllers:

[source,java]
----
@RestController
public class DevelopmentController {
    
    private final AgentClient agentClient;
    
    public DevelopmentController(AgentClient agentClient) {
        this.agentClient = agentClient;
    }
    
    @PostMapping("/generate-tests")
    public ResponseEntity<String> generateTests(@RequestBody GenerateTestsRequest request) {
        try {
            AgentClientResponse response = agentClient
                .goal("Generate unit tests for " + request.getClassName())
                .workingDirectory(request.getProjectPath())
                .yolo(false) // Safe mode for production
                .run();
                
            if (response.isSuccessful()) {
                return ResponseEntity.ok(response.getResult());
            } else {
                return ResponseEntity.badRequest().body(response.getResult());
            }
            
        } catch (Exception e) {
            return ResponseEntity.status(500).body("Goal execution failed: " + e.getMessage());
        }
    }
}
----

== Best Practices

=== Goal Formulation

Write clear, specific goals:

[source,java]
----
// Good: Specific and actionable
client.run("Add input validation to the UserController.createUser() method");

// Poor: Vague and ambiguous
client.run("Make the code better");
----

=== Working Directory Management

Always set appropriate working directories:

[source,java]
----
// For multi-module projects
client.goal("Generate integration tests")
    .workingDirectory(projectRoot.resolve("service-module"))
    .run();
----

=== Resource Management

AgentClient instances are thread-safe and can be reused:

[source,java]
----
@Component
public class CodeGenerationService {
    
    private final AgentClient agentClient;
    
    public CodeGenerationService(AgentClient agentClient) {
        this.agentClient = agentClient;
    }
    
    // Reuse the same client instance across methods
    public String generateController(String entityName) {
        return agentClient.run("Generate REST controller for " + entityName).getResult();
    }
    
    public String generateTests(String className) {
        return agentClient.run("Generate unit tests for " + className).getResult();
    }
}
----

== Advanced Features

=== Timeout Configuration

Configure execution timeouts:

[source,java]
----
AgentOptions options = AgentOptions.builder()
    .timeout(Duration.ofMinutes(15)) // Long-running refactoring goal
    .build();

client.goal("Refactor entire codebase to use reactive patterns")
    .options(options)
    .run();
----

=== Result Streaming

For long-running tasks, some agents support progress updates:

[source,java]
----
// Note: Streaming support varies by agent implementation
AgentClientResponse response = client
    .goal("Generate comprehensive test suite")
    .options(AgentOptions.builder().streaming(true).build())
    .run();

// Implementation-specific streaming access
if (response instanceof StreamingAgentResponse streaming) {
    streaming.getProgressUpdates().forEach(System.out::println);
}
----

== Working with Advisors

Agent Advisors provide powerful interception points for augmenting agent execution, following the same pattern as Spring AI's ChatClient advisors.

=== Configuring Advisors

Register advisors at build time using the builder's `defaultAdvisor()` or `defaultAdvisors()` methods:

[source,java]
----
AgentClient client = AgentClient.builder(agentModel)
    .defaultAdvisor(new SimpleLoggerAdvisor())
    .defaultAdvisor(new WorkspaceContextAdvisor())
    .build();
----

=== Common Use Cases

==== Logging and Observability

Monitor agent execution with custom metrics and logging:

[source,java]
----
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

public class MetricsAdvisor implements AgentCallAdvisor {

	private final MeterRegistry meterRegistry;

	public MetricsAdvisor(MeterRegistry meterRegistry) {
		this.meterRegistry = meterRegistry;
	}

	@Override
	public AgentClientResponse adviseCall(AgentClientRequest request, AgentCallAdvisorChain chain) {
		Timer.Sample sample = Timer.start(meterRegistry);
		try {
			AgentClientResponse response = chain.nextCall(request);
			sample.stop(Timer.builder("agent.execution")
				.tag("success", String.valueOf(response.isSuccessful()))
				.register(meterRegistry));
			return response;
		} catch (Exception e) {
			sample.stop(Timer.builder("agent.execution")
				.tag("success", "false")
				.register(meterRegistry));
			throw e;
		}
	}

	@Override
	public String getName() {
		return "Metrics";
	}

	@Override
	public int getOrder() {
		return 0;
	}
}
----

==== Context Engineering

Inject additional context before agent execution (see xref:future/context-engineering.adoc[Context Engineering]):

* Clone git repositories
* Sync vendor dependencies
* Gather project metadata
* Prepare test fixtures

Example:

[source,java]
----
public class WorkspaceContextAdvisor implements AgentCallAdvisor {

	@Override
	public AgentClientResponse adviseCall(AgentClientRequest request, AgentCallAdvisorChain chain) {
		// Inject workspace info into context before execution
		Path workspace = request.workingDirectory();
		String workspaceInfo = analyzeWorkspace(workspace);
		request.context().put("workspace_info", workspaceInfo);

		// Continue the chain
		AgentClientResponse response = chain.nextCall(request);

		// Add execution metrics to response context
		response.context().put("files_modified", countModifiedFiles(response));
		return response;
	}

	private String analyzeWorkspace(Path workspace) {
		// Implementation details...
		return "Workspace analyzed";
	}

	private int countModifiedFiles(AgentClientResponse response) {
		// Implementation details...
		return 0;
	}

	@Override
	public String getName() {
		return "WorkspaceContext";
	}

	@Override
	public int getOrder() {
		return 100;
	}
}
----

==== Post-Execution Evaluation

Validate agent output and enforce quality standards (see xref:future/judge-concept.adoc[Judge Concept]):

* Verify file existence
* Run test suites
* Check code quality metrics
* Validate against schemas

Example:

[source,java]
----
public class TestExecutionAdvisor implements AgentCallAdvisor {

	@Override
	public AgentClientResponse adviseCall(AgentClientRequest request, AgentCallAdvisorChain chain) {
		// Execute the agent goal
		AgentClientResponse response = chain.nextCall(request);

		// Post-execution: run tests to validate the changes
		if (response.isSuccessful()) {
			boolean testsPass = runTests(request.workingDirectory());
			response.context().put("tests_passed", testsPass);

			if (!testsPass) {
				// Optionally modify response to indicate failure
				System.err.println("WARNING: Tests failed after agent execution");
			}
		}

		return response;
	}

	private boolean runTests(Path workingDirectory) {
		// Run test suite and return result
		return true; // Placeholder
	}

	@Override
	public String getName() {
		return "TestExecution";
	}

	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE - 100; // Run near the end
	}
}
----

==== Security and Validation

Enforce security policies before execution:

[source,java]
----
public class GoalValidationAdvisor implements AgentCallAdvisor {

	private final List<String> bannedOperations = List.of("rm -rf", "DROP DATABASE");

	@Override
	public AgentClientResponse adviseCall(AgentClientRequest request, AgentCallAdvisorChain chain) {
		String goal = request.goal().getContent().toLowerCase();

		// Block dangerous operations
		for (String banned : bannedOperations) {
			if (goal.contains(banned.toLowerCase())) {
				// Return failure response without executing
				return new AgentClientResponse(
					createBlockedResponse("Goal blocked: dangerous operation")
				);
			}
		}

		return chain.nextCall(request);
	}

	private AgentResponse createBlockedResponse(String reason) {
		// Create blocked response
		return new AgentResponse(List.of(
			new AgentGeneration(reason, new AgentGenerationMetadata("BLOCKED", Map.of()))
		));
	}

	@Override
	public String getName() {
		return "GoalValidation";
	}

	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE; // Execute first for security
	}
}
----

=== Spring Boot Integration

Register advisors as Spring beans for automatic discovery:

[source,java]
----
@Configuration
public class AgentAdvisorConfiguration {

	@Bean
	public AgentCallAdvisor metricsAdvisor(MeterRegistry meterRegistry) {
		return new MetricsAdvisor(meterRegistry);
	}

	@Bean
	public AgentCallAdvisor validationAdvisor() {
		return new GoalValidationAdvisor();
	}

	@Bean
	public AgentClient agentClient(
			AgentModel agentModel,
			List<AgentCallAdvisor> advisors) { // Auto-injects all advisor beans
		return AgentClient.builder(agentModel)
			.defaultAdvisors(advisors)
			.build();
	}
}
----

=== Learn More

For complete advisor documentation, see xref:api/advisors.adoc[Agent Advisors API].

== Next Steps

* Master the xref:api/advisors.adoc[Agent Advisors API] for advanced execution control
* Learn how AgentClient compares to ChatClient in xref:api/agentclient-vs-chatclient.adoc[AgentClient vs ChatClient]
* Explore agent-specific features in xref:api/claude-code-sdk.adoc[Claude Code SDK]
* See real-world examples in xref:samples.adoc[Sample Agents]