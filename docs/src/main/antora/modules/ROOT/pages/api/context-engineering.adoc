= Context Engineering
:page-title: Context Engineering with VendirContextAdvisor
:toc: left
:tabsize: 2
:sectnums:

Context engineering provides AI agents with rich, structured external reference materials to improve reasoning and decision-making.

== Overview

**Context engineering** is the practice of providing AI agents with "the right information, at the right time, in the right format." For autonomous development agents, this means gathering external documentation, API specifications, examples, and best practices before agent execution.

The `VendirContextAdvisor` implements the **"Select Context"** strategy using https://carvel.dev/vendir/[vendir] to declaratively fetch external content into the agent's workspace.

== Why Context Engineering?

Most agent failures are context failures, not model failures. Agents make better decisions when they have access to:

* **Framework documentation** - Understanding APIs and patterns
* **API specifications** - Correct usage of external services
* **Best practices** - Industry-standard approaches
* **Examples** - Real-world usage patterns

Without proper context, agents may:

* Hallucinate non-existent APIs
* Use deprecated patterns
* Miss important conventions
* Make suboptimal architectural decisions

== Context Engineering vs RAG

A fundamental shift is happening in AI systems: **direct context engineering is replacing traditional RAG** (Retrieval-Augmented Generation) with vector stores for many agent workflows.

=== The Shift from Vector Search to File Access

Traditional LLM applications use vector stores and embedding-based similarity search. Agent systems are shifting to direct file access and navigation.

==== Sources Supporting This Shift

**1. Anthropic Engineering Blog**

In https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk[Building Agents with the Claude Agent SDK], Anthropic explains:

[quote, Anthropic Engineering]
____
Rather than relying on vector similarity search, agents can directly access codebases, search files with grep, and navigate directory structures—providing more precise and reliable context than approximate embeddings.
____

**2. Latent Space Podcast with LangChain**

Harrison Chase (founder of LangChain) discusses how file-based context is replacing traditional semantic search for agent workflows in this podcast: https://www.youtube.com/watch?v=_IlTcWciEC4[Latent Space: Context Engineering]

[NOTE]
====
The observation from LangChain—a framework that pioneered vector-based RAG—validates this architectural shift toward direct file access for agents.
====

=== Why Context > RAG for Agents

[cols="1,1,1"]
|===
|Aspect |Traditional RAG |Context Engineering

|**Retrieval**
|Vector similarity search
|Direct file access + grep

|**Accuracy**
|Approximate (embeddings)
|Exact (string matching)

|**Recall**
|Top-k results (~80-90%)
|Perfect (grep finds all matches)

|**Complexity**
|Vector DB + embeddings + chunking
|File system operations

|**Agent Fit**
|Static retrieval
|Dynamic navigation

|**Latency**
|Embedding + vector search
|Native OS operations (faster)

|**Infrastructure**
|Vector database, embedding API
|File system only
|===

=== Example: Finding OAuth2 Configuration

**Traditional RAG Approach**:

[source,java]
----
// ❌ Complex: Vector store + embeddings + chunking
VectorStore vectorStore = new PgVectorStore(...);

// Embed all documentation
List<Document> docs = loadDocumentation();
vectorStore.add(docs);

// Query with similarity search
List<Document> results = vectorStore.similaritySearch(
    SearchRequest.query("How to configure OAuth2?")
        .withTopK(5)
        .withSimilarityThreshold(0.8)
);

// Hope the right docs are in top-5...
String context = results.stream()
    .map(Document::getContent)
    .collect(Collectors.joining("\n"));
----

**Context Engineering Approach**:

[source,java]
----
// ✅ Simple: Agent explores directly
AgentClientResponse response = agentClientBuilder
    .goal("Find examples of OAuth2 configuration in the Spring Security docs")
    .workingDirectory(projectRoot)
    .advisors(
        VendirContextAdvisor.builder()
            .vendirConfigPath("vendir-spring-security.yml")
            .build()
    )
    .call();

// Agent dynamically:
// 1. grep -r "OAuth2" docs/
// 2. find . -name "*OAuth*"
// 3. Read relevant files
// 4. Navigate to related examples
// 5. Synthesize answer
----

=== Benefits of Context Engineering

==== Perfect Recall

`grep` finds **all** matches, not approximate top-k:

[source,bash]
----
# Agent can do this:
$ grep -r "OAuth2" docs/
# Finds EVERY occurrence

# vs Vector search top-5 (might miss important results)
----

==== Dynamic Navigation

Agents can follow references:

[source,text]
----
1. Find "@Configuration" classes
2. Notice import for OAuth2ClientConfig
3. Navigate to OAuth2ClientConfig.java
4. Read implementation details
5. Follow to examples

Vector search: Static top-k results
Agent: Dynamic navigation following code references
----

==== No Embedding Overhead

[source,text]
----
Traditional RAG:
1. Chunk documents
2. Generate embeddings (API calls + cost)
3. Store in vector DB
4. Query with embeddings (more API calls)
5. Post-process results

Context Engineering:
1. Give agent file access
2. Agent uses grep/find (instant, free)
----

==== Simpler Architecture

[source,text]
----
Traditional RAG Stack:
┌─────────────────┐
│   Application   │
└────────┬────────┘
         │
┌────────▼────────┐
│  Vector Store   │
│  (Postgres +    │
│   pgvector)     │
└────────┬────────┘
         │
┌────────▼────────┐
│ Embedding API   │
│  (OpenAI/etc)   │
└─────────────────┘

Context Engineering Stack:
┌─────────────────┐
│   Application   │
└────────┬────────┘
         │
┌────────▼────────┐
│  File System    │
└─────────────────┘

(That's it!)
----

=== When RAG Still Makes Sense

Context engineering doesn't replace RAG everywhere:

**Use Context Engineering When**:

* ✅ Working with codebases (files have structure)
* ✅ Need exact file/directory navigation
* ✅ Agent can explore dynamically
* ✅ Documents have references (imports, links)
* ✅ Precision is critical (no false positives)

**Use RAG When**:

* ✅ Searching across massive unstructured corpora
* ✅ Need semantic similarity (not exact match)
* ✅ Content doesn't have file/code structure
* ✅ One-shot retrieval (no navigation needed)
* ✅ User queries are semantic ("find documents about...")

=== Context Engineering in Practice

VendirContextAdvisor implements context engineering by fetching relevant documentation into the agent's workspace:

[source,java]
----
// Fetch Spring Security documentation
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .build();

AgentClientResponse response = agentClientBuilder
    .goal("Implement OAuth2 login following Spring Security best practices")
    .advisors(advisor)
    .call();

// Agent has direct file access to:
// - Spring Security reference docs
// - Code examples
// - Configuration templates
// - Migration guides

// Agent can grep, navigate, read—no vector store needed
----

== VendirContextAdvisor

The `VendirContextAdvisor` automatically gathers external context before agent execution using vendir configuration files.

=== Basic Usage

[source,java]
----
// Create vendir configuration
Path vendirConfig = createVendirConfig(); // vendir.yml

// Create advisor
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath(vendirConfig)
    .contextDirectory(".agent-context/vendir")
    .build();

// Register with AgentClient
AgentClient client = AgentClient.builder(agentModel)
    .defaultAdvisor(advisor)
    .build();

// Execute - context is gathered automatically before agent runs
AgentClientResponse response = client.run(
    "Implement Spring Boot actuator health endpoint following best practices"
);
----

=== Vendir Configuration

Create a `vendir.yml` file specifying what external content to fetch:

[source,yaml]
----
apiVersion: vendir.k14s.io/v1alpha1
kind: Config
directories:
- path: vendor
  contents:
  # Clone entire repository
  - path: spring-guide
    git:
      url: https://github.com/spring-guides/gs-rest-service
      ref: main
      depth: 1    # Shallow clone for efficiency

  # Fetch specific paths
  - path: spring-boot-docs
    git:
      url: https://github.com/spring-projects/spring-boot
      ref: v3.3.0
      depth: 1
    includePaths:
    - README.adoc

  # HTTP source
  - path: api-specs
    http:
      url: https://example.com/api-spec.yaml
----

For complete vendir configuration options, see the https://carvel.dev/vendir/docs/latest/vendir-spec/[official vendir documentation].

== Configuration Options

=== Context Directory

Specify where context files are placed:

[source,java]
----
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .contextDirectory(".agent-context/vendir") // Default
    .build();
----

Context files are placed in `{workingDirectory}/.agent-context/vendir/vendor/`.

=== Timeout

Configure how long vendir has to fetch content:

[source,java]
----
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .timeout(300) // 5 minutes (default)
    .build();
----

=== Auto-cleanup

Optionally remove context files after agent execution:

[source,java]
----
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .autoCleanup(true) // Default: false (keep for inspection)
    .build();
----

=== Execution Order

Control when context is gathered relative to other advisors:

[source,java]
----
import org.springframework.core.Ordered;

VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .order(Ordered.HIGHEST_PRECEDENCE + 100) // Default: early execution
    .build();
----

== Context Metadata

The advisor adds metadata to request/response contexts for observability:

[source,java]
----
AgentClientResponse response = client.run("Some goal");

// Check if context was gathered successfully
Boolean success = (Boolean) response.context().get("vendir.context.success");
String contextPath = (String) response.context().get("vendir.context.path");
String output = (String) response.context().get("vendir.context.output");

if (!success) {
    String error = (String) response.context().get("vendir.context.error");
    logger.warn("Context gathering failed: {}", error);
}
----

== Examples

=== Clone Entire Repository

[source,yaml]
----
apiVersion: vendir.k14s.io/v1alpha1
kind: Config
directories:
- path: vendor
  contents:
  - path: spring-guide
    git:
      url: https://github.com/spring-guides/gs-rest-service
      ref: main
      depth: 1
----

[source,java]
----
VendirContextAdvisor advisor = VendirContextAdvisor.builder()
    .vendirConfigPath("vendir.yml")
    .build();

AgentClient client = AgentClient.builder(agentModel)
    .defaultAdvisor(advisor)
    .build();

client.run("Based on the Spring guide, create a similar REST service for products");
----

=== Fetch Specific Files

[source,yaml]
----
apiVersion: vendir.k14s.io/v1alpha1
kind: Config
directories:
- path: vendor
  contents:
  - path: spring-boot
    git:
      url: https://github.com/spring-projects/spring-boot
      ref: v3.3.0
      depth: 1
    includePaths:
    - README.adoc
----

=== HTTP Sources

[source,yaml]
----
apiVersion: vendir.k14s.io/v1alpha1
kind: Config
directories:
- path: vendor
  contents:
  - path: api-spec
    http:
      url: https://api.example.com/openapi.yaml
----

== Spring Boot Integration

Register as a Spring bean for automatic configuration:

[source,java]
----
@Configuration
public class ContextEngineeringConfig {

    @Bean
    public VendirContextAdvisor vendirContextAdvisor() {
        return VendirContextAdvisor.builder()
            .vendirConfigPath("context/vendir.yml")
            .contextDirectory(".agent-context")
            .timeout(300)
            .autoCleanup(false)
            .build();
    }

    @Bean
    public AgentClient agentClient(
            AgentModel agentModel,
            VendirContextAdvisor contextAdvisor) {
        return AgentClient.builder(agentModel)
            .defaultAdvisor(contextAdvisor)
            .build();
    }
}
----

== Error Handling

The advisor handles failures gracefully:

* **Vendir not installed** - Logs error, agent continues without context
* **Network failures** - Logs error, agent continues without context
* **Invalid configuration** - Logs error, agent continues without context
* **Timeout** - Logs error, agent continues without context

Failures are recorded in the context for observability:

[source,java]
----
AgentClientResponse response = client.run("Some goal");

if (!(Boolean) response.context().get("vendir.context.success")) {
    String error = (String) response.context().get("vendir.context.error");
    // Handle degraded execution
}
----

== Tips

* Use `depth: 1` for faster shallow clones
* Use `includePaths` to fetch only relevant files
* Keep `autoCleanup: false` during development to inspect gathered context
* Adjust timeout based on repository size



== Related Concepts

* xref:api/advisors.adoc[Agent Advisors] - Complete advisor pattern documentation
* xref:api/agentclient.adoc[AgentClient] - High-level client API
* xref:future/judge-concept.adoc[Judge Concept] - Post-execution validation

---

Context engineering transforms autonomous agents from isolated tools into context-aware developers that understand and respect external APIs, frameworks, and best practices.
