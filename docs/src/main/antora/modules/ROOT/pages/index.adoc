= Spring AI Agents
:page-title: Spring AI Agents
:toc: left
:tabsize: 2
:sectnums:

Spring AI Agents is a community-maintained library that brings autonomous agents into mainstream Java enterprise development, making them as easy to use as any other Spring component.

== The Agent Evolution

> **"There are a lot of things that people are building right now that will eventually be washed away by scale."**
> — Noam Brown, OpenAI Research Lead (Latent Space Podcast, June 2025)

The way we build AI agents is changing rapidly. What worked six months ago is becoming obsolete. What's emerging is simpler, more powerful, and fundamentally different.

=== Then: Annotation-Based Tool Calling

Early agent approaches used **method annotations** to define tools:

[source,java]
----
@Tool("Searches Google for relevant URLs")
public List<String> searchGoogle(@P("search query") String query) {
    return googleSearchService.search(query);
}
----

This approach required:

* **Predefined tools** - Developers wrote Java methods for every possible action
* **Linear conversation history** - Back-and-forth LLM interactions with tool calls
* **Limited scope** - Only actions you explicitly coded were available

[NOTE]
====
Spring AI fully supports this approach too—with `@Tool` annotations and first-class https://spring.io/blog/2025/03/17/model-context-protocol-mcp-in-spring-ai[Model Context Protocol (MCP)] integration for building LLM-based tools. This remains valuable for certain use cases.
====

The limitation: agents were constrained to predefined Java methods. Want to run `grep`? Write a GrepTool. Want to use `sed`? Write a SedTool. The combinatorial explosion of "what if the agent needs X?" led to heavy scaffolding.

=== Now: Reasoning Models + Direct Computer Access

Then reasoning models arrived (OpenAI o1, Claude 3.7 Sonnet). Noam Brown observed: _"Before reasoning models, there was extensive work engineering agentic systems with complex calls to non-reasoning models. When reasoning models were created, you don't need this complex behavior. You just give the reasoning model the same question without any sort of scaffolding and it just does it."_

**The new paradigm**: Give agents direct access to the computer—bash, file systems, git—and let the reasoning model figure out the steps.

This is exactly what https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk[Anthropic's Claude Agent SDK] (renamed from Claude Code SDK in September 2025) demonstrates:

[quote, Anthropic Engineering Blog]
The agent loop is: *gather context → take action → verify work → repeat*. The agent writes files, runs commands, and iterates on its work until the goal is achieved.

**No annotations. No predefined workflows. Just a goal, a workspace, and direct computer access.**

=== What Persists: Lightweight Integration & Evaluation

Noam Brown's guidance for developers:

* ❌ **Don't invest in**: Complex routing, heavy scaffolding that compensates for model limitations
* ✅ **Do invest in**: Reward/environment design, evaluation pipelines, minimal tooling for safety/telemetry

This is exactly what **Spring AI Agents** provides:

* **Lightweight integration** - Thin Spring Boot abstraction over CLI agents (Claude, Gemini, etc.)
* **Evaluation-first** - Judge API for deterministic and AI-powered verification
* **Vendor flexibility** - Switch agents as the landscape evolves
* **Safety layers** - Sandboxes, permissions, monitoring

We're not building another workflow orchestration framework. We're building the **pragmatic integration layer** that connects Spring Boot applications to the future of autonomous agents.

== Why CLI Agents?

Spring AI Agents focuses specifically on **autonomous CLI agents** - agents that execute goals by directly interacting with your computer through command-line interfaces.

Unlike traditional frameworks where you define workflows in code, CLI agents:

* **Execute bash commands** - `mvn test`, `git commit`, `grep`, `sed`—anything you can type in a terminal
* **Navigate file systems** - Read, write, search across entire codebases
* **Iterate autonomously** - Keep working until the goal is achieved
* **Adapt dynamically** - The reasoning model decides the workflow, not predefined code

Example: _"Upgrade Spring Boot from 2.7 to 3.2 and fix breaking changes"_

The agent:
1. Finds the current version in pom.xml
2. Updates to 3.2
3. Runs `mvn compile` and sees javax.* errors
4. Searches for affected files with `grep`
5. Replaces javax.servlet with jakarta.servlet
6. Runs `mvn test` to verify

**All autonomously. No predefined workflow. Just a goal and direct computer access.**

=== Human-in-the-Loop vs Autonomous

Different tools for different needs:

* **Human-in-the-loop** (Copilot, ChatGPT): Exploration, clarification, pair programming
* **Autonomous CLI agents** (Claude Code, Gemini CLI): Execute well-defined goals end-to-end

Spring AI Agents makes autonomous agents as easy to use in Spring Boot as ChatClient is for conversational AI.

== Key Features

* **Zero-Setup Quick Start** - Try agents via JBang catalog without cloning or building
* **ChatClient-style API** - Same fluent patterns Spring developers already know
* **JBang Agent Runner** - Primary developer entry point for trying agents locally with LocalSandbox
* **Multiple agent providers** - Claude Code, Gemini CLI, SWE Agent support (more to come!)
* **Fluent API design** - Clean, intuitive interface following Spring patterns
* **Spring Boot ready** - Auto-configuration and dependency injection support
* **Production essentials** - Built-in error handling, timeouts, and metadata
* **Evaluation-first design** - Judge API for deterministic and AI-powered verification

== Why Java? Why Now?

The agent ecosystem has a **Python bias**. Most benchmarks, research, and tooling assume Python workflows. But enterprise software development is multi-language, and Java remains the backbone of mission-critical systems.

=== The Benchmark Reality

* **SWE-bench**: Python-centric, curated dataset with inflated scores
* **SWE-bench-Live**: More realistic fresh issues—scores drop significantly
* **Multi-SWE-bench & SWE-PolyBench** (2025): Added Java, revealed Python bias—Java agents score lower not because they're worse, but because benchmarks don't reflect Java workflows

=== Spring AI Bench (Coming)

We're building **Spring AI Bench**—an open-source benchmark suite for Java that evaluates agents on goal-directed, enterprise workflows. Following BetterBench best practices for reproducibility and contamination resistance.

**Philosophy**: Let the best agent per use case win. Benchmark ALL approaches—annotation-based tools, CLI agents, custom solutions—and measure what actually matters: Can it achieve the goal? At what cost? With what reliability?

Early validation from **Netflix**, **JetBrains**, and **Fiserv** confirms the approach.

== Agent Providers

Spring AI Agents supports multiple autonomous agent platforms:

[cols="1,2,2"]
|===
|Provider |Description |Best For

|Claude Agent SDK
|Anthropic's autonomous coding agent (renamed Sept 2025)
|General software development, debugging, refactoring

|Gemini CLI  
|Google's command-line coding agent
|Google ecosystem integration, specialized tasks

|SWE Agent
|Software engineering benchmark agent (work in progress)
|Research tasks, systematic problem solving
|===

== Requirements

* Java 17 or higher
* Maven 3.6.3 or higher
* Agent CLI tools installed (Claude, Gemini, etc.)
* Valid API keys for your chosen providers

== Getting Started

Get started using Spring AI Agents by following our xref:getting-started.adoc[Getting Started] guide.

== Documentation

* xref:jbang-runner.adoc[JBang Agent Runner] - Primary developer entry point for trying agents locally
* xref:api/agentclient.adoc[AgentClient API] - Learn the core API for running autonomous tasks
* xref:api/agentclient-vs-chatclient.adoc[AgentClient vs ChatClient] - See how AgentClient follows ChatClient patterns
* xref:api/claude-code-sdk.adoc[Claude Code SDK] - Java integration with Claude Code CLI
* xref:api/gemini-cli-sdk.adoc[Gemini CLI SDK] - Java integration with Gemini CLI
* xref:samples.adoc[Sample Agents] - Real-world agent examples and patterns

== Contributing

We welcome contributions to Spring AI Agents! Please see our xref:contribution-guidelines.adoc[Contribution Guidelines] for more information on how to get involved.

== The Vision

Spring AI Agents is the pragmatic integration layer for autonomous agents in Java enterprise development.

We're not building heavy scaffolding that will "wash away with scale." We're building what persists:

* **Lightweight integration** - Spring Boot patterns for any CLI agent
* **Evaluation infrastructure** - Judge API and Spring AI Bench for measuring what matters
* **Vendor flexibility** - Switch agents as models and tools evolve
* **Safety and observability** - Sandboxes, permissions, monitoring

**The landscape is changing fast.** Invest in what complements model scaling, not what gets replaced by it.