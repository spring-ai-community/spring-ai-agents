= Spring AI Agents
:page-title: Spring AI Agents
:toc: left
:tabsize: 2
:sectnums:

Spring AI Agents is a community-maintained library that brings autonomous agents into mainstream Java enterprise development, making them as easy to use as any other Spring component.

== What Is an Agent?

> **"An agent is a LLM in a loop"**
> — Common saying in AI engineering

At the core, every agent is an **LLM executing a loop**: think → act (via tools) → observe → repeat until the goal is achieved.

=== You Can Build This Yourself

Spring AI provides the building blocks to create your own "LLM in a loop":

* **`@Tool` annotations** - Define custom tools as Java methods
* **Model Context Protocol (MCP)** - https://spring.io/blog/2025/03/17/model-context-protocol-mcp-in-spring-ai[First-class MCP integration] for standard tool interfaces
* **Linear conversation history** - Manage context and tool-calling interactions
* **Spring integration** - Familiar Spring Boot patterns

You have complete control to build custom agent loops for your specific needs.

=== Or Use Production-Ready CLI Agents

Here's the key question: **Why reinvent the wheel?**

Leading AI companies have invested heavily in production-ready autonomous agents:

* **Claude Agent SDK** (Anthropic) - https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk[Renamed from Claude Code SDK in Sept 2025]
* **Gemini CLI** (Google) - Multimodal agent with direct computer access
* **Amazon Q Developer** - AWS-integrated autonomous coding
* **OpenAI Codex agents** - GPT-powered development tools

These tools are:

* **Cutting-edge** - Built by teams pushing the frontier of AI
* **Battle-tested** - Used by millions of developers
* **Constantly improving** - New models, capabilities, optimizations

At their core, they're all "LLMs in a loop" too—but with massive R&D investment, sophisticated optimizations, and production polish.

=== The Spring AI Agents Approach

**Spring AI Agents makes these powerful CLI agents accessible to Spring developers.**

Instead of building everything from scratch, we provide:

* **Lightweight integration** - Thin Spring Boot abstraction over CLI agents
* **Vendor flexibility** - Switch between Claude, Gemini, etc. as tools evolve
* **Evaluation infrastructure** - Judge API for verifying agent work
* **Safety layers** - Sandboxes, permissions, monitoring
* **Spring patterns** - Familiar `AgentClient` API mirroring `ChatClient`

**The philosophy**: Use cutting-edge production agents where they excel. Build custom tools with Spring AI's `@Tool`/MCP where you need control. Combine both as needed.

== Why CLI Agents?

Spring AI Agents focuses specifically on **autonomous CLI agents** - agents that execute goals by directly interacting with your computer through command-line interfaces.

=== Context Engineering Through the File System

> **"The delicate art and science of filling the context window with just the right information"**
> — Andrej Karpathy on context engineering

A major challenge with agents is **context growth**. A typical agent task requires https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus[~50 tool calls] (Manus AI), and as context grows:

* Performance drops (https://research.trychroma.com/context-rot[Chroma research on "context rot"])
* Costs increase (every token in context costs money)
* Latency increases (more tokens to process)
* Quality degrades (LLMs struggle with very long contexts)

**CLI agents solve this through the file system**:

* **Write context to files** - Instead of keeping everything in LLM memory, agents write `todo.md`, research plans, intermediate results to files
* **Read context when needed** - Retrieve specific files only when relevant to the current step
* **Persistent state** - File system provides durable storage across agent iterations

This is https://rlancemartin.github.io/2025/06/23/context_engineering/[context engineering] in practice. Examples:

* **Manus AI**: Writes `todo.md` at task start, rewrites during execution. Recitation of objectives helps maintain focus without bloating context.
* **Anthropic multi-agent researcher**: https://anthropic.com/engineering/built-multi-agent-research-system[Writes research plans to files] so they can be retrieved as needed
* **Cursor/Windsurf**: Use sophisticated retrieval to assemble relevant code into prompts without overwhelming context

CLI agents **naturally** do context engineering because they operate through bash and file systems—reading, writing, searching files is their native mode.

=== Direct Computer Access

Unlike frameworks where you define tools in code, CLI agents:

* **Execute any bash command** - `mvn test`, `git commit`, `grep`, `sed`—anything you can type in a terminal
* **Navigate file systems** - Read, write, search across entire codebases
* **Iterate autonomously** - Keep working until the goal is achieved
* **Use files as context** - Write intermediate state, read when needed

Example: _"Upgrade Spring Boot from 2.7 to 3.2 and fix breaking changes"_

The agent:
1. Finds the current version in pom.xml
2. Updates to 3.2
3. Runs `mvn compile` and sees javax.* errors
4. **Writes error summary to analysis.md** (context engineering)
5. Searches for affected files with `grep`
6. Replaces javax.servlet with jakarta.servlet
7. Runs `mvn test` to verify
8. **Reads analysis.md to confirm all issues resolved**

**All autonomously. No predefined workflow. Context managed through the file system.**

=== Human-in-the-Loop vs Autonomous

Different tools for different needs:

* **Human-in-the-loop** (Copilot, ChatGPT): Exploration, clarification, pair programming
* **Autonomous CLI agents** (Claude Agent SDK, Gemini CLI): Execute well-defined goals end-to-end with file-based context management

Spring AI Agents makes autonomous agents as easy to use in Spring Boot as ChatClient is for conversational AI.

== Key Features

* **Zero-Setup Quick Start** - Try agents via JBang catalog without cloning or building
* **ChatClient-style API** - Same fluent patterns Spring developers already know
* **JBang Agent Runner** - Primary developer entry point for trying agents locally with LocalSandbox
* **Multiple agent providers** - Claude Code, Gemini CLI, SWE Agent support (more to come!)
* **Fluent API design** - Clean, intuitive interface following Spring patterns
* **Spring Boot ready** - Auto-configuration and dependency injection support
* **Production essentials** - Built-in error handling, timeouts, and metadata
* **Evaluation-first design** - Judge API for deterministic and AI-powered verification

== Why Java? Why Now?

The agent ecosystem has a **Python bias**. Most benchmarks, research, and tooling assume Python workflows. But enterprise software development is multi-language, and Java remains the backbone of mission-critical systems.

=== The Benchmark Reality

* **SWE-bench**: Python-centric, curated dataset with inflated scores
* **SWE-bench-Live**: More realistic fresh issues—scores drop significantly
* **Multi-SWE-bench & SWE-PolyBench** (2025): Added Java, revealed Python bias—Java agents score lower not because they're worse, but because benchmarks don't reflect Java workflows

=== Spring AI Bench (Coming)

We're building **Spring AI Bench**—an open-source benchmark suite for Java that evaluates agents on goal-directed, enterprise workflows. Following BetterBench best practices for reproducibility and contamination resistance.

**Philosophy**: Let the best agent per use case win. Benchmark ALL approaches—annotation-based tools, CLI agents, custom solutions—and measure what actually matters: Can it achieve the goal? At what cost? With what reliability?

Early validation from **Netflix**, **JetBrains**, and **Fiserv** confirms the approach.

== Agent Providers

Spring AI Agents supports multiple autonomous agent platforms:

[cols="1,2,2"]
|===
|Provider |Description |Best For

|Claude Agent SDK
|Anthropic's autonomous coding agent (renamed Sept 2025)
|General software development, debugging, refactoring

|Gemini CLI  
|Google's command-line coding agent
|Google ecosystem integration, specialized tasks

|SWE Agent
|Software engineering benchmark agent (work in progress)
|Research tasks, systematic problem solving
|===

== Requirements

* Java 17 or higher
* Maven 3.6.3 or higher
* Agent CLI tools installed (Claude, Gemini, etc.)
* Valid API keys for your chosen providers

== Getting Started

Get started using Spring AI Agents by following our xref:getting-started.adoc[Getting Started] guide.

== Documentation

* xref:jbang-runner.adoc[JBang Agent Runner] - Primary developer entry point for trying agents locally
* xref:api/agentclient.adoc[AgentClient API] - Learn the core API for running autonomous tasks
* xref:api/agentclient-vs-chatclient.adoc[AgentClient vs ChatClient] - See how AgentClient follows ChatClient patterns
* xref:api/claude-code-sdk.adoc[Claude Code SDK] - Java integration with Claude Code CLI
* xref:api/gemini-cli-sdk.adoc[Gemini CLI SDK] - Java integration with Gemini CLI
* xref:samples.adoc[Sample Agents] - Real-world agent examples and patterns

== Contributing

We welcome contributions to Spring AI Agents! Please see our xref:contribution-guidelines.adoc[Contribution Guidelines] for more information on how to get involved.

== The Vision

Spring AI Agents is the pragmatic integration layer for autonomous agents in Java enterprise development.

We're not building heavy scaffolding that will "wash away with scale." We're building what persists:

* **Lightweight integration** - Spring Boot patterns for any CLI agent
* **Evaluation infrastructure** - Judge API and Spring AI Bench for measuring what matters
* **Vendor flexibility** - Switch agents as models and tools evolve
* **Safety and observability** - Sandboxes, permissions, monitoring

**The landscape is changing fast.** Invest in what complements model scaling, not what gets replaced by it.