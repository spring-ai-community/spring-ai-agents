= Spring AI Agents
:page-title: Spring AI Agents
:toc: left
:tabsize: 2
:sectnums:

Spring AI Agents is a community-maintained library that brings autonomous agents into mainstream Java enterprise development, making them as easy to use as any other Spring component.

== What Is an Agent?

> **"An agent is a LLM in a loop"**
> — Common saying in AI engineering

At the core, every agent is an **LLM executing a loop**: think → act (via tools) → observe → repeat until the goal is achieved.

The key components:
* **LLM as the workflow engine** - The LLM plans and decides what to do next
* **xref:concepts/goals.adoc[Goals]** - Clear objectives that guide agent execution
* **Tools** - Actions the agent can take (call APIs, run commands, read files)
* **xref:concepts/context-engineering.adoc[Context]** - Information the agent needs to make decisions
* **xref:judges/index.adoc[Judges]** - Verification that the goal was achieved

=== The Paradigm Shift

Building agents is hard. The industry has gone through a fundamental shift:

**Old paradigm**: _"The LLM can't plan workflows, so we must code them"_

* Developer writes the workflow logic in code
* Developer defines which tool to call when
* Developer handles error cases and retries
* Heavy scaffolding to compensate for model limitations

**New paradigm**: _"The LLM IS the workflow engine"_

* Developer provides goals, context, and available tools
* LLM decides the plan and execution steps
* LLM adapts when things go wrong
* Minimal scaffolding - trust the reasoning model

This shift makes agent development almost **declarative** (describe what you want) rather than **imperative** (code every step).

=== Two Paths Forward

Both approaches are valid and coexist:

==== Path 1: Build Your Own Agent

Spring AI provides the building blocks to create custom "LLM in a loop" agents:

* **`@Tool` annotations** - Define tools as Java methods
* **Model Context Protocol (MCP)** - https://spring.io/blog/2025/03/17/model-context-protocol-mcp-in-spring-ai[First-class MCP support]
* **Conversation history** - Manage context and tool interactions
* **Spring integration** - Familiar Spring Boot patterns

**When to build your own**:
* Domain-specific workflows
* Custom tool integrations
* Full control over agent behavior

**The challenge**: Building effective agents is **hard**. You're solving problems that companies like Anthropic, Google, and OpenAI invest heavily in: context management, error recovery, planning, tool selection, performance optimization.

**Can you build the agent loop yourself?** Yes! https://github.com/SWE-agent/mini-swe-agent[Mini-swe-agent] proves it's possible with a simple "LLM in a loop executing bash commands" approach. And we will build custom agents for specific needs.

**But here's the reality**: Many companies are investing heavily in this space. **Why not try them out? Validate them with benchmarking.** That's where https://github.com/spring-ai-community/spring-ai-bench[Spring AI Bench] comes in—working hand-in-hand with Spring AI Agents to measure what actually matters.

==== Path 2: Use Production-Ready CLI Agents

Here's the key realization: **Leading AI companies have figured this out.**

Production CLI agents like Claude Agent SDK, Gemini CLI, Amazon Q Developer, and OpenAI Codex agents have:

* Sophisticated context engineering
* Proven planning and execution strategies
* Constant model improvements
* Battle-tested on millions of tasks
* Massive ongoing R&D investment

**Why not take advantage of this?**

Using these tools is **declarative**:

[source,java]
----
// Declarative: Describe the goal
agentClientBuilder
    .goal("Upgrade Spring Boot from 2.7 to 3.2 and fix breaking changes")
    .workingDirectory(projectRoot)
    .call();

// vs Imperative: Code every step
public void upgrade() {
    updatePomVersion();
    runBuild();
    if (buildFails()) {
        List<File> affectedFiles = findJavaxImports();
        replaceJavaxWithJakarta(affectedFiles);
        runBuild();
    }
    // ... dozens more conditional branches
}
----

**The Spring AI Agents Approach**: Make production CLI agents accessible to Spring developers with:

* **Lightweight integration** - Thin Spring Boot abstraction
* **Vendor flexibility** - Switch between Claude, Gemini, etc.
* **Evaluation infrastructure** - xref:judges/index.adoc[Judge API] for verification
* **Agent sandbox** - xref:concepts/sandboxes.adoc[Isolated execution]
* **Spring patterns** - Familiar xref:api/agentclient.adoc[AgentClient] API

**Both paths coexist**: Use CLI agents for general development tasks. Build custom agents with Spring AI's `@Tool`/MCP for specialized needs. Combine both when appropriate.

== Why CLI Agents?

Spring AI Agents focuses specifically on **autonomous CLI agents** - agents that execute goals by directly interacting with your computer through command-line interfaces.

=== Context Engineering Through the File System

> **"The delicate art and science of filling the context window with just the right information"**
> — Andrej Karpathy on context engineering

A major challenge with agents is **context growth**. A typical agent task requires https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus[~50 tool calls] (Manus AI), and as context grows:

* Performance drops (https://research.trychroma.com/context-rot[Chroma research on "context rot"])
* Costs increase (every token in context costs money)
* Latency increases (more tokens to process)
* Quality degrades (LLMs struggle with very long contexts)

**CLI agents solve this through the file system**:

* **Write context to files** - Instead of keeping everything in LLM memory, agents write `todo.md`, research plans, intermediate results to files
* **Read context when needed** - Retrieve specific files only when relevant to the current step
* **Persistent state** - File system provides durable storage across agent iterations

This is https://rlancemartin.github.io/2025/06/23/context_engineering/[context engineering] in practice. Examples:

* **Manus AI**: Writes `todo.md` at task start, rewrites during execution. Recitation of objectives helps maintain focus without bloating context.
* **Anthropic multi-agent researcher**: https://anthropic.com/engineering/built-multi-agent-research-system[Writes research plans to files] so they can be retrieved as needed
* **Cursor/Windsurf**: Use sophisticated retrieval to assemble relevant code into prompts without overwhelming context

CLI agents **naturally** do context engineering because they operate through bash and file systems—reading, writing, searching files is their native mode.

=== Direct Computer Access

Unlike frameworks where you define tools in code, CLI agents:

* **Execute any bash command** - `mvn test`, `git commit`, `grep`, `sed`—anything you can type in a terminal
* **Navigate file systems** - Read, write, search across entire codebases
* **Iterate autonomously** - Keep working until the goal is achieved
* **Use files as context** - Write intermediate state, read when needed

Example: _"Upgrade Spring Boot from 2.7 to 3.2 and fix breaking changes"_

The agent:
1. Finds the current version in pom.xml
2. Updates to 3.2
3. Runs `mvn compile` and sees javax.* errors
4. **Writes error summary to analysis.md** (context engineering)
5. Searches for affected files with `grep`
6. Replaces javax.servlet with jakarta.servlet
7. Runs `mvn test` to verify
8. **Reads analysis.md to confirm all issues resolved**

**All autonomously. No predefined workflow. Context managed through the file system.**

=== Human-in-the-Loop vs Autonomous

Different tools for different needs:

* **Human-in-the-loop** (Copilot, ChatGPT): Exploration, clarification, pair programming
* **Autonomous CLI agents** (Claude Agent SDK, Gemini CLI): Execute well-defined goals end-to-end with file-based context management

Spring AI Agents makes autonomous agents as easy to use in Spring Boot as ChatClient is for conversational AI.

== Key Features

* **Zero-Setup Quick Start** - Try agents via JBang catalog without cloning or building
* **ChatClient-style API** - Same fluent patterns Spring developers already know
* **JBang Agent Runner** - Primary developer entry point for trying agents locally with LocalSandbox
* **Multiple agent providers** - Claude Code, Gemini CLI, SWE Agent support (more to come!)
* **Fluent API design** - Clean, intuitive interface following Spring patterns
* **Spring Boot ready** - Auto-configuration and dependency injection support
* **Production essentials** - Built-in error handling, timeouts, and metadata
* **Evaluation-first design** - Judge API for deterministic and AI-powered verification

== Why Java? Why Now?

The agent ecosystem has a **Python bias**. Most benchmarks, research, and tooling assume Python workflows. But enterprise software development is multi-language, and Java remains the backbone of mission-critical systems.

=== The Benchmark Reality

* **SWE-bench**: Python-centric, curated dataset with inflated scores
* **SWE-bench-Live**: More realistic fresh issues—scores drop significantly
* **Multi-SWE-bench & SWE-PolyBench** (2025): Added Java, revealed Python bias—Java agents score lower not because they're worse, but because benchmarks don't reflect Java workflows

=== Spring AI Bench

We're building https://github.com/spring-ai-community/spring-ai-bench[**Spring AI Bench**]—an open-source benchmark suite for Java that evaluates agents on goal-directed, enterprise workflows. Following https://betterbench.stanford.edu/[BetterBench] best practices for reproducibility and contamination resistance.

Spring AI Bench and Spring AI Agents work hand-in-hand: **Spring AI Agents provides the integration layer**, making it easy to run different agents (Claude, Gemini, custom solutions). **Spring AI Bench provides the measurement framework**, evaluating which agent performs best for which scenario.

**Philosophy**: Let the best agent per use case win. Benchmark ALL approaches—annotation-based tools, CLI agents, custom solutions—and measure what actually matters:

* **Can it achieve the goal?** Success rate
* **At what cost?** Token usage, API costs
* **How fast?** Execution time
* **How reliably?** Consistency across runs

Different use cases optimize for different metrics:

* **Fastest at least cost** - Routine tasks, CI/CD automation
* **Longest but most accurate** - Critical migrations, security audits
* **Somewhere in between** - Most development tasks

**We'll learn which agent wins for which scenario.** That's the point of benchmarking.

Early validation from **Netflix**, **JetBrains**, and **Fiserv** confirms the approach.

== Agent Providers

Spring AI Agents supports multiple autonomous agent platforms:

[cols="1,2,2"]
|===
|Provider |Description |Best For

|Claude Agent SDK
|Anthropic's autonomous coding agent (renamed Sept 2025)
|General software development, debugging, refactoring

|Gemini CLI  
|Google's command-line coding agent
|Google ecosystem integration, specialized tasks

|SWE Agent
|Software engineering benchmark agent (work in progress)
|Research tasks, systematic problem solving
|===

== Requirements

* Java 17 or higher
* Maven 3.6.3 or higher
* Agent CLI tools installed (Claude, Gemini, etc.)
* Valid API keys for your chosen providers

== Getting Started

Get started using Spring AI Agents by following our xref:getting-started.adoc[Getting Started] guide.

== Documentation

* xref:jbang-runner.adoc[JBang Agent Runner] - Primary developer entry point for trying agents locally
* xref:api/agentclient.adoc[AgentClient API] - Learn the core API for running autonomous tasks
* xref:api/agentclient-vs-chatclient.adoc[AgentClient vs ChatClient] - See how AgentClient follows ChatClient patterns
* xref:api/claude-code-sdk.adoc[Claude Code SDK] - Java integration with Claude Code CLI
* xref:api/gemini-cli-sdk.adoc[Gemini CLI SDK] - Java integration with Gemini CLI
* xref:samples.adoc[Sample Agents] - Real-world agent examples and patterns

== Contributing

We welcome contributions to Spring AI Agents! Please see our xref:contribution-guidelines.adoc[Contribution Guidelines] for more information on how to get involved.

== The Vision

Spring AI Agents is the pragmatic integration layer for autonomous agents in Java enterprise development.

We're not building heavy scaffolding that will "wash away with scale." We're building what persists:

* **Lightweight integration** - Spring Boot patterns for any CLI agent
* **Evaluation infrastructure** - xref:judges/index.adoc[Judge API] and https://github.com/spring-ai-community/spring-ai-bench[Spring AI Bench] for measuring what matters
* **Vendor flexibility** - Switch agents as models and tools evolve
* **Agent sandbox** - xref:concepts/sandboxes.adoc[Isolated execution]

**The landscape is changing fast.** Invest in what complements model scaling, not what gets replaced by it.